-- SecretFinder — Fully merged script (no ignored place id, no normalization lines, mutation detection, ESP)
if not game:IsLoaded() then game.Loaded:Wait() end

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local PLACE_ID = 109983668079237

-- Updated ranking: ALL Gods first (1..22) then Secrets (23..49)
local brainrotRanking = {
    -- Gods (highest priority)
    ["Cocofanto Elefanto"] = 1,
    ["Girafa Celestre"] = 2,
    ["Matteo"] = 3,
    ["Tralalero Tralala"] = 4,
    ["Odin Din Din Dun"] = 5,
    ["Unclito Samito"] = 6,
    ["Trenostruzzo Turbo 3000"] = 7,
    ["Brainrot God Lucky Block"] = 8,
    ["Ballerino Lololo"] = 9,
    ["Los Crocodillitos"] = 10,
    ["Piccione Macchina"] = 11,
    ["Trippi Troppi Troppa Trippa"] = 12,
    ["Bulbito Bandito Traktorito"] = 13,
    ["Los Orcalitos"] = 14,
    ["Tigroligre Frutonni"] = 15,
    ["Espresso Signora"] = 16,
    ["Orcalero Orcala"] = 17,
    ["Pakrahmatmamat"] = 18,
    ["Tartaruga Cisterna"] = 19,
    ["Alessio"] = 20,
    ["Brr es Teh Patipum"] = 21,
    ["Los Bombinitos"] = 22,

    -- Secrets (lower priority than Gods)
    ["Dragon Cannelloni"] = 23,
    ["Garama And Madundung"] = 24,
    ["Esok Sekolah"] = 25,
    ["Los Hotspotsitos"] = 26,
    ["Nuclearo Dinossauro"] = 27,
    ["Los Combinasionas"] = 28,
    ["La Grande Combinasion"] = 29,
    ["Chicleteira Bicicleteira"] = 30,
    ["Secret Lucky Block"] = 31,
    ["Pot Hotspot"] = 32,
    ["Graipuss Medussi"] = 33,
    ["Las Vaquitas Saturnitas"] = 34,
    ["Job Job Job Sahur"] = 35,
    ["Las Tralaleritas"] = 36,
    ["Los Tralaleritos"] = 37,
    ["Agarrini La Palini"] = 38,
    ["Torrtuginni Dragonfrutini"] = 39,
    ["Chimpanzini Spiderini"] = 40,
    ["Sammyini Spidreini"] = 41,
    ["Los Matteos"] = 42,
    ["Karkerkar Kurkur"] = 43,
    ["La Vacca Saturno Saturnita"] = 44,
    ["Dul Dul Dul"] = 45,
    ["Blackhole Goat"] = 46,
    ["La Supreme Combinasion"] = 47,
    ["Bisonte Giuppitere"] = 48,
    ["Ketupat Kepat"] = 49,
}

-- Replaced / expanded brainrotGods (from your provided list)
local brainrotGods = {
    ["Cocofanto Elefanto"] = true,
    ["Girafa Celestre"] = true,
    ["Matteo"] = true,
    ["Tralalero Tralala"] = true,
    ["Odin Din Din Dun"] = true,
    ["Unclito Samito"] = true,
    ["Trenostruzzo Turbo 3000"] = true,
    ["Brainrot God Lucky Block"] = true,
    ["Ballerino Lololo"] = true,
    ["Los Crocodillitos"] = true,
    ["Piccione Macchina"] = true,
    ["Trippi Troppi Troppa Trippa"] = true,
    ["Bulbito Bandito Traktorito"] = true,
    ["Los Orcalitos"] = true,
    ["Tigroligre Frutonni"] = true,
    ["Espresso Signora"] = true,
    ["Orcalero Orcala"] = true,
    ["Pakrahmatmamat"] = true,
    ["Tartaruga Cisterna"] = true,
    ["Alessio"] = true,
    ["Brr es Teh Patipum"] = true,
    ["Los Bombinitos"] = true,
}

-- Secrets list (green ESP) - added from your provided list
local brainrotSecrets = {
    ["Dragon Cannelloni"] = true,
    ["Garama And Madundung"] = true,
    ["Esok Sekolah"] = true,
    ["Los Hotspotsitos"] = true,
    ["Nuclearo Dinossauro"] = true,
    ["Los Combinasionas"] = true,
    ["La Grande Combinasion"] = true,
    ["Chicleteira Bicicleteira"] = true,
    ["Secret Lucky Block"] = true,
    ["Pot Hotspot"] = true,
    ["Graipuss Medussi"] = true,
    ["Las Vaquitas Saturnitas"] = true,
    ["Job Job Job Sahur"] = true,
    ["Las Tralaleritas"] = true,
    ["Los Tralaleritos"] = true,
    ["Agarrini La Palini"] = true,
    ["Torrtuginni Dragonfrutini"] = true,
    ["Chimpanzini Spiderini"] = true,
    ["Sammyini Spidreini"] = true,
    ["Los Matteos"] = true,
    ["Karkerkar Kurkur"] = true,
    ["La Vacca Saturno Saturnita"] = true,
    ["Dul Dul Dul"] = true,
    ["Blackhole Goat"] = true,
    ["La Supreme Combinasion"] = true,
    ["Bisonte Giuppitere"] = true,
    ["Ketupat Kepat"] = true,
}

local toolsToBuy = {
    "Invisibility Cloak",
    "Medusa's Head",
    "Quantum Cloner",
    "All Seeing Sentry",
    "Body Swap Potion",
    "Rainbowrath Sword"
}

local BuyRemote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RF/CoinsShopService/RequestBuy")
getgenv().VisitedServers = getgenv().VisitedServers or {}

-- ---------- Mutation color palette + helper ----------
local colorGold     = Color3.fromRGB(237, 178, 0)
local colorDiamond  = Color3.fromRGB(37, 196, 254)
local colorCandy    = Color3.fromRGB(255, 182, 255)
local colorLava     = Color3.fromRGB(255, 94, 0)
local colorGalaxy   = Color3.fromRGB(140, 91, 159)
local colorNone     = Color3.fromRGB(163, 162, 165)
local COLOR_EPSILON = 0.02

local function colorsAreClose(a, b)
    if typeof(a) ~= "Color3" or typeof(b) ~= "Color3" then return false end
    return math.abs(a.R - b.R) < COLOR_EPSILON
       and math.abs(a.G - b.G) < COLOR_EPSILON
       and math.abs(a.B - b.B) < COLOR_EPSILON
end

local function getMutation(rootPart)
    if not rootPart or not rootPart:IsA("BasePart") then
        return "⚪ None"
    end
    local col = rootPart.Color
    if colorsAreClose(col, colorGold) then
        return "🌕 Gold"
    elseif colorsAreClose(col, colorDiamond) then
        return "💎 Diamond"
    elseif colorsAreClose(col, colorCandy) then
        return "🍬 Candy"
    elseif colorsAreClose(col, colorLava) then
        return "🌋 Lava"
    elseif colorsAreClose(col, colorGalaxy) then
        return "🌌 Galaxy"
    elseif colorsAreClose(col, colorNone) then
        return "⚪ None"
    else
        return "⚪ None"
    end
end

local function mutationToColor(mutationText)
    if not mutationText then return nil end
    if mutationText:find("Gold") then return colorGold end
    if mutationText:find("Diamond") then return colorDiamond end
    if mutationText:find("Candy") then return colorCandy end
    if mutationText:find("Lava") then return colorLava end
    if mutationText:find("Galaxy") then return colorGalaxy end
    return nil
end

-- Helper: find the first BasePart to attach adornments/labels
local function getFirstRenderablePart(model)
    if not model or not model:IsA("Model") then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then
            return d
        end
    end
    return nil
end

-- parse user's config mutation for a given name
-- accepted config forms:
--  getgenv().BrainrotConfig[name] == true
--  getgenv().BrainrotConfig[name] == { Enabled = true, Mutation = "Lava" }  (Mutation can be "Any", "None", "Gold", etc)
local function getConfigEntry(name)
    if not getgenv().BrainrotConfig then return nil end
    local v = getgenv().BrainrotConfig[name]
    if v == nil then return nil end
    -- boolean true shorthand
    if v == true then
        return { Enabled = true, Mutation = "Any" }
    end
    if type(v) == "table" then
        local enabled = v.Enabled
        if enabled == nil then enabled = true end
        local mutation = v.Mutation or v.mutation or "Any"
        return { Enabled = enabled, Mutation = mutation }
    end
    -- fallback: treat truthy as enabled any
    return { Enabled = true, Mutation = "Any" }
end

local function sanitizeMutationName(s)
    if not s then return "" end
    s = tostring(s)
    s = s:gsub("🌕", ""):gsub("💎",""):gsub("🍬",""):gsub("🌋",""):gsub("🌌","")
    s = s:gsub("%s+", "") -- remove whitespace
    return s:lower()
end

-- Reliable highlighting using Roblox's Highlight + Billboard label
local function highlightModel(model, name, isGod, isSecret, mutationText)
    if not model or not model:IsA("Model") then return end
    if model:FindFirstChild("BrainrotHighlight") then return end

    local part = getFirstRenderablePart(model)
    if not part then return end

    local h = Instance.new("Highlight")
    h.Name = "BrainrotHighlight"
    h.Adornee = model
    h.Parent = model
    h.FillTransparency = 0.5
    h.OutlineTransparency = 0
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

    -- choose color: prefer mutation color if present; otherwise god/secret defaults
    local mutColor = mutationToColor(mutationText)
    if mutColor then
        h.FillColor = mutColor
        h.OutlineColor = mutColor
    else
        if isGod then
            h.FillColor = Color3.fromRGB(255, 200, 0)
            h.OutlineColor = Color3.fromRGB(255, 200, 0)
        elseif isSecret then
            h.FillColor = Color3.fromRGB(0, 255, 0)
            h.OutlineColor = Color3.fromRGB(0, 255, 0)
        else
            h.FillColor = Color3.fromRGB(0, 170, 255)
            h.OutlineColor = Color3.fromRGB(0, 170, 255)
        end
    end

    -- Billboard label (so you can read the name + mutation)
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "BrainrotLabel"
    billboard.Size = UDim2.new(0, 260, 0, 54)
    billboard.Adornee = part
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 3000
    billboard.StudsOffsetWorldSpace = Vector3.new(0, 4, 0)
    billboard.Parent = model

    local label = Instance.new("TextLabel")
    label.Name = "BrainrotLabelMain"
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 0.6, 0)
    label.Position = UDim2.new(0,0,0,0)
    label.Font = Enum.Font.GothamSemibold
    label.TextScaled = true
    label.TextStrokeTransparency = 0
    label.TextWrapped = true
    label.TextYAlignment = Enum.TextYAlignment.Top
    label.Text = (isGod and "Brainrot God - " or (isSecret and "Secret - " or "Unknown - ")) .. name
    if isGod then
        label.TextColor3 = Color3.fromRGB(255, 200, 0)
    elseif isSecret then
        label.TextColor3 = Color3.fromRGB(0, 255, 0)
    else
        label.TextColor3 = Color3.fromRGB(0, 170, 255)
    end
    label.Parent = billboard

    local subLabel = Instance.new("TextLabel")
    subLabel.Name = "BrainrotLabelMutation"
    subLabel.BackgroundTransparency = 1
    subLabel.Size = UDim2.new(1, 0, 0.4, 0)
    subLabel.Position = UDim2.new(0,0,0.6,0)
    subLabel.Font = Enum.Font.GothamSemibold
    subLabel.TextScaled = true
    subLabel.TextStrokeTransparency = 0
    subLabel.TextWrapped = true
    subLabel.TextYAlignment = Enum.TextYAlignment.Top
    subLabel.Text = mutationText or "⚪ None"
    subLabel.TextColor3 = (mutationToColor(mutationText) or Color3.fromRGB(200,200,200))
    subLabel.Parent = billboard
end

local function autoBuyTools()
    for _, toolName in ipairs(toolsToBuy) do
        pcall(function()
            BuyRemote:InvokeServer(toolName)
        end)
        task.wait(1.6)
    end
end

local function showFoundGui(foundName, isGod, isSecret, mutationText)
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local gui = playerGui:FindFirstChild("SecretFinderGUI")
    if gui then gui:Destroy() end

    gui = Instance.new("ScreenGui", playerGui)
    gui.Name = "SecretFinderGUI"
    gui.ResetOnSpawn = false

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 300, 0, 160)
    frame.Position = UDim2.new(0.5, -150, 0.38, 0)
    frame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    frame.BorderSizePixel = 0
    frame.AnchorPoint = Vector2.new(0.5, 0)

    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, -20, 0, 36)
    title.Position = UDim2.new(0, 10, 0, 8)
    title.Text = "✓ Secret or God Found!"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextScaled = true

    -- Found name + type
    local foundLabel = Instance.new("TextLabel", frame)
    foundLabel.Size = UDim2.new(1, -20, 0, 36)
    foundLabel.Position = UDim2.new(0,10,0,48)
    foundLabel.BackgroundTransparency = 1
    foundLabel.Font = Enum.Font.GothamSemibold
    foundLabel.TextScaled = true
    foundLabel.TextStrokeTransparency = 0
    foundLabel.TextWrapped = true
    if foundName then
        local ttype = (isGod and "Brainrot God" or (isSecret and "Secret" or "Unknown"))
        foundLabel.Text = string.format("%s - %s", ttype, foundName)
        if isGod then
            foundLabel.TextColor3 = Color3.fromRGB(255,200,0)
        elseif isSecret then
            foundLabel.TextColor3 = Color3.fromRGB(0,255,0)
        else
            foundLabel.TextColor3 = Color3.fromRGB(0,170,255)
        end
    else
        foundLabel.Text = "Unknown Model"
        foundLabel.TextColor3 = Color3.fromRGB(200,200,200)
    end

    -- Mutation label
    local mutLabel = Instance.new("TextLabel", frame)
    mutLabel.Size = UDim2.new(1, -20, 0, 24)
    mutLabel.Position = UDim2.new(0,10,0,92)
    mutLabel.BackgroundTransparency = 1
    mutLabel.Font = Enum.Font.GothamSemibold
    mutLabel.TextScaled = true
    mutLabel.TextStrokeTransparency = 0
    mutLabel.TextWrapped = true
    if mutationText then
        mutLabel.Text = "Mutation: " .. mutationText
        local mc = mutationToColor(mutationText)
        mutLabel.TextColor3 = mc or Color3.fromRGB(200,200,200)
    else
        mutLabel.Text = "Mutation: ⚪ None"
        mutLabel.TextColor3 = Color3.fromRGB(200,200,200)
    end

    local buyBtn = Instance.new("TextButton", frame)
    buyBtn.Size = UDim2.new(0.45, 0, 0, 36)
    buyBtn.Position = UDim2.new(0.05, 0, 0.8, 0)
    buyBtn.Text = "Buy Tools"
    buyBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    buyBtn.Font = Enum.Font.SourceSansBold
    buyBtn.TextColor3 = Color3.new(1, 1, 1)
    buyBtn.TextScaled = true

    local ignoreBtn = Instance.new("TextButton", frame)
    ignoreBtn.Size = UDim2.new(0.45, 0, 0, 36)
    ignoreBtn.Position = UDim2.new(0.5, 0, 0.8, 0)
    ignoreBtn.Text = "Ignore"
    ignoreBtn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    ignoreBtn.Font = Enum.Font.SourceSansBold
    ignoreBtn.TextColor3 = Color3.new(1, 1, 1)
    ignoreBtn.TextScaled = true

    buyBtn.MouseButton1Click:Connect(function()
        autoBuyTools()
        gui:Destroy()
    end)

    ignoreBtn.MouseButton1Click:Connect(function()
        gui:Destroy()
    end)
end

-- Use: returns true if this model should be considered based on getgenv().BrainrotConfig entry
local function matchesConfigFilter(model)
    if not model or not model:IsA("Model") or not getgenv().BrainrotConfig then return false end
    local entry = getConfigEntry(model.Name)
    if not entry or not entry.Enabled then return false end

    -- if the user requested a specific mutation, check it.
    local desired = entry.Mutation or "Any"
    if desired == "Any" or desired == "any" or desired == "" then
        return true
    end

    -- find a renderable part for the model and detect its mutation
    local part = getFirstRenderablePart(model)
    local actual = getMutation(part) -- e.g. "🌋 Lava"
    local sanitizedActual = sanitizeMutationName(actual) -- "lava"
    local sanitizedDesired = sanitizeMutationName(desired) -- "lava" if user set "Lava"
    -- allow "none" explicit
    return sanitizedActual == sanitizedDesired
end

-- NEW: highlight ALL brainrots matching your config (gods -> yellow, secrets -> green) and use mutation-based color
local function findAllAndHighlight()
    local anyFound = false
    local firstFoundInfo = nil

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("Model")
            and getgenv().BrainrotConfig
            and getgenv().BrainrotConfig[obj.Name]
        then
            -- Check config filtering (supports boolean or table with Mutation key)
            local entry = getConfigEntry(obj.Name)
            if entry and entry.Enabled then
                -- If user specified a Mutation filter (not Any), only accept matching mutation models
                local part = getFirstRenderablePart(obj)
                local mutationText = getMutation(part)
                local pass = false
                if entry.Mutation == "Any" or entry.Mutation == "any" or entry.Mutation == "" then
                    pass = true
                else
                    if sanitizeMutationName(mutationText) == sanitizeMutationName(entry.Mutation) then
                        pass = true
                    end
                end

                if pass then
                    local isGod = brainrotGods[obj.Name] == true
                    local isSecret = brainrotSecrets[obj.Name] == true
                    if not isGod and not isSecret and brainrotRanking[obj.Name] then
                        isSecret = true -- default to secret styling if only in ranking
                    end

                    highlightModel(obj, obj.Name, isGod, isSecret, mutationText)
                    anyFound = true
                    if not firstFoundInfo then
                        firstFoundInfo = { name = obj.Name, isGod = isGod, isSecret = isSecret, mutation = mutationText }
                    end
                end
            end
        end
    end

    if anyFound then
        -- show GUI giving the first found match's details
        if firstFoundInfo then
            showFoundGui(firstFoundInfo.name, firstFoundInfo.isGod, firstFoundInfo.isSecret, firstFoundInfo.mutation)
        else
            showFoundGui()
        end
    else
        task.wait(0.1)
        searchAllServers()
    end
end

-- searchAllServers with no ignored place id and no normalization lines
function searchAllServers(cursor)
    local url = "https://games.roblox.com/v1/games/" .. PLACE_ID .. "/servers/Public?sortOrder=Asc&limit=100"
    if cursor then url = url .. "&cursor=" .. cursor end

    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    if not success or not result or typeof(result.data) ~= "table" then
        task.wait(0.1)
        return searchAllServers()
    end

    for _, server in ipairs(result.data) do
        -- skip servers we've already visited and only join non-full servers
        if server and not getgenv().VisitedServers[server.id] and server.playing < server.maxPlayers then
            getgenv().VisitedServers[server.id] = true
            task.delay(0.1, function()
                pcall(function()
                    TeleportService:TeleportToPlaceInstance(PLACE_ID, server.id, LocalPlayer)
                end)
            end)
            return
        end
    end

    if result.nextPageCursor then
        task.wait(0.1)
        searchAllServers(result.nextPageCursor)
    else
        task.wait(0.1)
        searchAllServers()
    end
end

-- Continuous highlight updater: auto-refresh highlights every 0.2s
local highlightedModels = {}

local function removeHighlightFromModel(model)
    if not model or not model:IsA("Model") then return end
    local h = model:FindFirstChild("BrainrotHighlight")
    if h then pcall(function() h:Destroy() end) end

    -- remove any BillboardGui named BrainrotLabel inside the model
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BillboardGui") and desc.Name == "BrainrotLabel" then
            pcall(function() desc:Destroy() end)
        end
    end

    highlightedModels[model] = nil
end

task.spawn(function()
    while task.wait(0.2) do
        local anyFound = false
        local currentMatches = {}
        local firstFoundInfo = nil

        -- scan for matching models
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("Model")
                and getgenv().BrainrotConfig
                and getgenv().BrainrotConfig[obj.Name]
                and (brainrotRanking[obj.Name] or brainrotSecrets[obj.Name] or brainrotGods[obj.Name])
            then
                -- apply config filtering per-model
                local entry = getConfigEntry(obj.Name)
                if entry and entry.Enabled then
                    local part = getFirstRenderablePart(obj)
                    local mutationText = getMutation(part)
                    local pass = false
                    if entry.Mutation == "Any" or entry.Mutation == "any" or entry.Mutation == "" then
                        pass = true
                    else
                        if sanitizeMutationName(mutationText) == sanitizeMutationName(entry.Mutation) then
                            pass = true
                        end
                    end

                    if pass then
                        currentMatches[obj] = true
                        anyFound = true

                        if not highlightedModels[obj] then
                            local isGod = brainrotGods[obj.Name] == true
                            local isSecret = brainrotSecrets[obj.Name] == true
                            if not isGod and not isSecret and brainrotRanking[obj.Name] then
                                isSecret = true
                            end

                            pcall(function()
                                highlightModel(obj, obj.Name, isGod, isSecret, mutationText)
                            end)

                            highlightedModels[obj] = true
                        end

                        if not firstFoundInfo then
                            firstFoundInfo = { name = obj.Name, isGod = brainrotGods[obj.Name] == true, isSecret = brainrotSecrets[obj.Name] == true, mutation = mutationText }
                        end
                    end
                end
            end
        end

        -- remove highlights for models that no longer match or were removed
        for model, _ in pairs(highlightedModels) do
            if (not currentMatches[model]) or (not model.Parent) then
                pcall(function() removeHighlightFromModel(model) end)
            end
        end

        if anyFound then
            -- ensure the GUI is shown (but don't spam-create it)
            local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
            if playerGui and not playerGui:FindFirstChild("SecretFinderGUI") then
                pcall(function()
                    if firstFoundInfo then
                        showFoundGui(firstFoundInfo.name, firstFoundInfo.isGod, firstFoundInfo.isSecret, firstFoundInfo.mutation)
                    else
                        showFoundGui()
                    end
                end)
            end
        else
            -- nothing found in this server: continue searching/hopping
            pcall(function() searchAllServers() end)
        end
    end
end)
